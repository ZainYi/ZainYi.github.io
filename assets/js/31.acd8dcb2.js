(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{198:function(t,_,a){t.exports=a.p+"assets/img/002001.cf0df8f1.png"},213:function(t,_,a){"use strict";a.r(_);var s=[function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"flask"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flask","aria-hidden":"true"}},[t._v("#")]),t._v(" flask")]),t._v(" "),s("h2",{attrs:{id:"要点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#要点","aria-hidden":"true"}},[t._v("#")]),t._v(" 要点")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("flask 路由遵循最小原型和唯一 URL 原则")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("@app.route()")]),t._v(" 装饰器控制路由，修饰视图函数")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("app.add_url_rule()")]),t._v(" 注册路由 e.g "),s("code",[t._v("app.add_url_rule('/hello', view_func=hello)")]),t._v("，但是绝大多数情况都是用装饰器的方式")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("app.run()")]),t._v(" 参数配置")]),t._v(" "),s("ul",[s("li",[t._v("debug 是否开启调试模式 e.g debug=True，生产环境 debug='off'")]),t._v(" "),s("li",[t._v("host 服务器主机 e.g host=0.0.0.0")]),t._v(" "),s("li",[t._v("port 端口")])])]),t._v(" "),s("li",[s("p",[t._v("读取配置 "),s("code",[t._v("app.config.from_object()")]),t._v(" config 是继承 dict 字典的子类，配置文件里面的常量必须全大写 'DEBUG' 是个默认参数，默认为 False")])]),t._v(" "),s("li",[s("p",[t._v("为什么用判断 "),s("code",[t._v("if __name__ == '__main__'")])]),t._v(" "),s("ul",[s("li",[t._v("判断文件是否作为入口文件而不是被其他文件所调用")]),t._v(" "),s("li",[t._v("生产环境部署时，一般不会使用 flask 自带的服务器，而是用 nginx+uwsgi 来部署项目，所以入口文件很有可能被其他程序调用，所以要加上这个判断")])])]),t._v(" "),s("li",[s("p",[t._v("视图函数是被封装过的函数，与普通函数不同，它会返回与 http 协议相关的一些内容")]),t._v(" "),s("ul",[s("li",[t._v("status-code、content-type 等")]),t._v(" "),s("li",[t._v("视图函数返回的都是 Response 对象")]),t._v(" "),s("li",[t._v("通过 make_response 方法创建 Response 对象，并由视图函数返回")]),t._v(" "),s("li",[t._v("视图函数可以直接返回一个元组 "),s("code",[t._v("return '<h2>Flask</h2>', 200, 'text/html'")])])])]),t._v(" "),s("li",[s("p",[t._v("requests 与 urllib 对比")]),t._v(" "),s("ul",[s("li",[t._v("requests 是第三方包\n"),s("ul",[s("li",[t._v("request 无以下操作")])])]),t._v(" "),s("li",[t._v("urllib 内置包\n"),s("ul",[s("li",[t._v("使用 "),s("code",[t._v("quote()")]),t._v(" 进行编码")]),t._v(" "),s("li",[s("code",[t._v("r.read()")]),t._v(" 去读取请求的内容，读出来的是字节码")]),t._v(" "),s("li",[t._v("使用 "),s("code",[t._v("str()")]),t._v(" 解析字节流")]),t._v(" "),s("li",[s("code",[t._v("try...catch")]),t._v(" 做异常处理")])])])])]),t._v(" "),s("li",[s("p",[t._v("flask 蓝图")]),t._v(" "),s("ul",[s("li",[t._v("blueprint")]),t._v(" "),s("li",[t._v("通过蓝图来组装视图函数")])])]),t._v(" "),s("li",[s("p",[t._v("flask Request 对象")]),t._v(" "),s("ul",[s("li",[t._v("Request")]),t._v(" "),s("li",[t._v("使用 wtforms 和 Flask_WTForms 做数据验证")])])]),t._v(" "),s("li",[s("p",[t._v("数据库创建表的方式")]),t._v(" "),s("ul",[s("li",[t._v("Database First")]),t._v(" "),s("li",[t._v("Model First")]),t._v(" "),s("li",[t._v("Code First\n"),s("ul",[s("li",[t._v("专注业务模型的设计，而不是专注数据库的设计")]),t._v(" "),s("li",[t._v("数据库只是用来存取数据的，表关系应该由业务来决定")]),t._v(" "),s("li",[t._v("ORM 对象关系映射 比 Code First 更广")])])])])]),t._v(" "),s("li",[s("p",[t._v("python 连接数据库")]),t._v(" "),s("ul",[s("li",[t._v("sqlalchemy")]),t._v(" "),s("li",[t._v("Flask_SQLAlchemy")]),t._v(" "),s("li",[s("code",[t._v("SQLALCHEMY_DATABASE_URI = 'mysql+cymysql://root:123456@localhost:3306/fisher'")])]),t._v(" "),s("li",[s("code",[t._v("SQLALCHEMY_TRACK_MODIFICATIONS = False")])])])])]),t._v(" "),s("h2",{attrs:{id:"flask-核心"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flask-核心","aria-hidden":"true"}},[t._v("#")]),t._v(" flask 核心")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Flask")]),t._v(" app 核心对象")]),t._v(" "),s("li",[s("code",[t._v("Request")]),t._v(" 请求核心对象")]),t._v(" "),s("li",[s("code",[t._v("AppContext")]),t._v(" 应用上下文\n"),s("ul",[s("li",[t._v("是对 "),s("code",[t._v("Flask")]),t._v(" 核心的包装")])])]),t._v(" "),s("li",[s("code",[t._v("RequestContext")]),t._v(" 请求上下文\n"),s("ul",[s("li",[t._v("是对 "),s("code",[t._v("Request")]),t._v(" 核心的包装")]),t._v(" "),s("li",[t._v("它要入栈会在逻辑上检查对应的 "),s("code",[t._v("AppContext")]),t._v(" 是否入栈")])])]),t._v(" "),s("li",[s("code",[t._v("request")]),t._v(" 请求上下文栈顶对象\n"),s("ul",[s("li",[t._v("实际上是根据 "),s("code",[t._v("name")]),t._v(" 返回的一个对象")]),t._v(" "),s("li",[t._v("通过 "),s("code",[t._v("LocalProxy()")]),t._v(" 获取")])])]),t._v(" "),s("li",[s("code",[t._v("current_app")]),t._v(" 应用上下文栈顶对象\n"),s("ul",[s("li",[t._v("实际上返回的是 app 核心对象")]),t._v(" "),s("li",[t._v("通过 "),s("code",[t._v("LocalProxy()")]),t._v(" 获取")])])]),t._v(" "),s("li",[t._v("通过 "),s("code",[t._v("ctx = app.app_context()")]),t._v(" 创建一个应用上下文\n"),s("ul",[s("li",[s("code",[t._v("ctx.push()")]),t._v(" 压栈")]),t._v(" "),s("li",[s("code",[t._v("ctx.pop()")]),t._v(" 弹栈")])])]),t._v(" "),s("li",[s("code",[t._v("with")]),t._v(" 语句，上下文表达式\n"),s("ul",[s("li",[t._v("实现了 "),s("code",[t._v("__enter__")]),t._v(" 和 "),s("code",[t._v("__exit__")]),t._v(" 方法，就可以使用 "),s("code",[t._v("with")]),t._v(" 语句，即实现了上下文协议")]),t._v(" "),s("li",[t._v("上下文管理器包含："),s("code",[t._v("__enter__")]),t._v(" 和 "),s("code",[t._v("__exit__")])]),t._v(" "),s("li",[s("code",[t._v("__exit__")]),t._v(" 返回 "),s("code",[t._v("False")]),t._v(" 则 "),s("code",[t._v("with")]),t._v(" 外部会继续抛出异常，"),s("code",[t._v("True")]),t._v(" 则不会")]),t._v(" "),s("li",[t._v("用处：链接数据库、文件读写")]),t._v(" "),s("li",[t._v("一些地方可以替代 "),s("code",[t._v("try except finally")])]),t._v(" "),s("li",[t._v("as 后面的变量是 "),s("code",[t._v("__enter__")]),t._v(" 返回的值")])])])]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{attrs:{class:"token keyword"}},[t._v("with")]),t._v(" app"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("app_context"),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n    a "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" current_app\n    "),s("span",{attrs:{class:"token keyword"}},[t._v("print")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    b "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" current_app"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("config"),s("span",{attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{attrs:{class:"token string"}},[t._v("'DEBUG'")]),s("span",{attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),s("span",{attrs:{class:"token keyword"}},[t._v("with")]),t._v(" "),s("span",{attrs:{class:"token builtin"}},[t._v("open")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("r"),s("span",{attrs:{class:"token string"}},[t._v("'path'")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token keyword"}},[t._v("as")]),t._v(" f"),s("span",{attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  "),s("span",{attrs:{class:"token keyword"}},[t._v("print")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("read"),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{attrs:{class:"token comment"}},[t._v("# f.close() 会自动执行")]),t._v("\n")])])]),s("p",[t._v("flask 核心流程图\n"),s("img",{attrs:{src:a(198),alt:"flask核心流程图"}})]),t._v(" "),s("h2",{attrs:{id:"进程和线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程","aria-hidden":"true"}},[t._v("#")]),t._v(" 进程和线程")]),t._v(" "),s("h3",{attrs:{id:"进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程","aria-hidden":"true"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),s("p",[t._v("计算机资源是有限的，应用程序需要去竞争计算机的资源，而进程是竞争计算机资源的基本单元")]),t._v(" "),s("p",[t._v("操作系统如何管理应用程序对计算机的资源进行竞争————进程管理。进程是操作系统用来调度和分配资源的单位。每个应用程序至少一个进程，操作系统调度不同的进程，让他们轮番的使用计算机的进程")]),t._v(" "),s("p",[t._v("单核 CPU，同一时刻只能运行一个应用程序，但 CPU 的运算速度足够快（快到感觉不到切换），所以 CPU 可以不同时刻在不同应用程序之间切换运行（进程调度）。进程/线程切换对系统的开销是比较大的，因为要切换应用程序的上下文，不同的应用程序的上下文是不一样的")]),t._v(" "),s("h3",{attrs:{id:"线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程","aria-hidden":"true"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),s("p",[t._v("线程是进程的一部分，一个进程可以有一个或者多个线程。CPU 越来越快，进程管理调度的粒度太大，不能高效利用 CPU 的性能，需要一个更小的单元来管理/使用 CPU 的资源，进程的切换非常笨重，所以需要更灵活的线程机制来协调 CPU 资源的利用，线程切换的消化远比进程切换要小。线程与进程最大的区别是分工不同，"),s("strong",[t._v("进程分配资源，线程利用 CPU 等资源执行代码或程序")])]),t._v(" "),s("h3",{attrs:{id:"多线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多线程","aria-hidden":"true"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{attrs:{class:"token keyword"}},[t._v("import")]),t._v(" threading\n\nt "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" threading"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("current_threading"),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token comment"}},[t._v("# 获取当前线程，默认是主线程")]),t._v("\n\nnew_t "),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" threading"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Thread"),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),s("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v("func"),s("span",{attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" name"),s("span",{attrs:{class:"token operator"}},[t._v("=")]),s("span",{attrs:{class:"token string"}},[t._v("'thread_name'")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token comment"}},[t._v("# 传入子线程执行的目标函数")]),t._v("\nnew_t"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("start"),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{attrs:{class:"token comment"}},[t._v("# 启动子线程，并不会阻塞主线程里的其他代码执行，只是启动")]),t._v("\n\n"),s("span",{attrs:{class:"token keyword"}},[t._v("print")]),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),t._v("t"),s("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("getName"),s("span",{attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("优点")]),t._v(" "),s("ul",[s("li",[t._v("更加充分的利用 CPU 的性能优势")]),t._v(" "),s("li",[t._v("异步编程")]),t._v(" "),s("li",[t._v("适合 IO 密集型的程序，查询数据库、请求网络资源、读写文件等")])]),t._v(" "),s("p",[t._v("缺点")]),t._v(" "),s("ul",[s("li",[t._v("python 不能充分利用多核 CPU 的优势，但并不一定是鸡肋")]),t._v(" "),s("li",[t._v("GIL 全局解释器锁，决定同一时刻一个 CPU 核上只能执行一个线程，GIL 是为了线程安全")]),t._v(" "),s("li",[t._v("严重依赖于 CPU 计算的程序来说，比较鸡肋（CPU 密集型的程序）")])]),t._v(" "),s("p",[t._v("flask")]),t._v(" "),s("ul",[s("li",[t._v("flask 默认是单进程、单线程的")]),t._v(" "),s("li",[t._v("通过指定关键参数 "),s("code",[t._v("threaded=True")]),t._v(" 开启多线程，"),s("code",[t._v("processs=2")]),t._v(" 开启多进程")]),t._v(" "),s("li",[t._v("flask 使用了 werkzeug 库来实现线程隔离，里面有一个 Local 对象用来做线程隔离，实际上就是对字典数据结构和线程 id 的封装")]),t._v(" "),s("li",[t._v("Local 使用字典的方式实现线程隔离")]),t._v(" "),s("li",[t._v("LocalStack 封装了 Local 对象，将其作为自己的一个私有属性，从而实现了线程隔离的栈结构")]),t._v(" "),s("li",[t._v("梳理\n"),s("ul",[s("li",[t._v("以线程 ID 号作为 key 的字典 → Local → LocalStack")]),t._v(" "),s("li",[t._v("AppContext、RequestContext → LocalStack")]),t._v(" "),s("li",[t._v("Flask → AppContext Request → RequestContext")]),t._v(" "),s("li",[t._v("current_app → (LocalStack.top = AppContext top.app=Flask)")]),t._v(" "),s("li",[t._v("request → (LocalStack.top = RequestContext top.Request=Request)")])])])]),t._v(" "),s("blockquote",[s("p",[t._v("使用线程隔离的意义：使当前线程能够正确引用到它自己创建的对象，而不是引用到其他线程所创建的对象，这些对象是保存状态的地方")])]),t._v(" "),s("h2",{attrs:{id:"面向对象滥用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象滥用","aria-hidden":"true"}},[t._v("#")]),t._v(" 面向对象滥用")]),t._v(" "),s("ul",[s("li",[t._v("面向对象应该描述特征（类变量、实例变量）")]),t._v(" "),s("li",[t._v("面向对象应该具有行为（方法）")]),t._v(" "),s("li",[t._v("只有方法的类，其实是伪装为面向对象的面向过程")]),t._v(" "),s("li",[t._v("一个类的方法大量标注了 "),s("code",[t._v("@classmethod @static")]),t._v("，即方法并未使用到任何类变量和实例变量，封装性不太好")])]),t._v(" "),s("h2",{attrs:{id:"python-序列化-class-类对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#python-序列化-class-类对象","aria-hidden":"true"}},[t._v("#")]),t._v(" python 序列化 class 类对象")]),t._v(" "),s("ul",[s("li",[t._v("使用 json 模块, "),s("code",[t._v("json.dumps(obj, default=lambda o:o.__dict__)")])]),t._v(" "),s("li",[t._v("函数式编程转义 json 序列化的代码解释权")])]),t._v(" "),s("h2",{attrs:{id:"flask-sqlacodegen"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flask-sqlacodegen","aria-hidden":"true"}},[t._v("#")]),t._v(" flask-sqlacodegen")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("pipe flask-sqlacodegen")])]),t._v(" "),s("li",[s("code",[t._v("flask-sqlacodegen mysql+cymysql://root:123456@localhost:3306/dbname --table tablename --outfile pathname")])])])])}],v=a(0),e=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},s,!1,null,null,null);e.options.__file="02-flask要点.md";_.default=e.exports}}]);